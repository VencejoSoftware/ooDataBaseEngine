{
  Copyright (c) 2019, Vencejo Software
  Distributed under the terms of the Modified BSD License
  The full license is distributed with this software
}
unit FirebirdEngine;

interface

uses
  SysUtils, StrUtils,
  DB,
  uib, uibdataset, uiblib, uibase,
  DatabaseLogin,
  ExecutionResult, FailedExecution, SuccededExecution, DatasetExecution,
  DatabaseEngine;

type
  TFirebirdEngine = class sealed(TInterfacedObject, IDatabaseEngine)
  strict private
    _Database: TUIBDatabase;
    _AlterTransaction: TUIBTransaction;
  private
    function ExecuteWithTransaction(const Statement: WideString; const Transaction: TUIBTransaction): IExecutionResult;
  public
    function InTransaction: Boolean;
    function BeginTransaction: Boolean;
    function CommitTransaction: Boolean;
    function RollbackTransaction: Boolean;
    function Connect(const Login: IDatabaseLogin): Boolean;
    function Disconnect: Boolean;
    function IsConnected: Boolean;
    function OpenDataset(const Statement: WideString): IExecutionResult;
    function Execute(const Statement: WideString; const UseGlobalTransaction: Boolean): IExecutionResult;
    function ExecuteReturning(const Statement: WideString; const UseGlobalTransaction: Boolean): IExecutionResult;
    constructor Create;
    destructor Destroy; override;
    class function New: IDatabaseEngine;
  end;

implementation

function TFirebirdEngine.InTransaction: Boolean;
begin
  Result := _AlterTransaction.InTransaction;
end;

function TFirebirdEngine.BeginTransaction: Boolean;
begin
  if not InTransaction then
    _AlterTransaction.StartTransaction;
  Result := True;
end;

function TFirebirdEngine.CommitTransaction: Boolean;
begin
  if InTransaction then
    _AlterTransaction.Commit;
  Result := True;
end;

function TFirebirdEngine.RollbackTransaction: Boolean;
begin
  if InTransaction then
    _AlterTransaction.RollBack;
  Result := True;
end;

function TFirebirdEngine.Connect(const Login: IDatabaseLogin): Boolean;
var
  Charset, Dialect, DBPath: WideString;
begin
  _Database.LibraryName := Login.Parameters.ItemByKey('LIB_PATH').Value;
  _Database.Params.Clear;
  _Database.UserName := Login.User;
  _Database.PassWord := Login.PassWord;
  if Login.Parameters.TryGetValue('CHARSET', Charset) then
  begin
    _Database.Params.Append(Format('DEFAULT CHARACTER SET %s', [Charset]));
    _Database.Params.Append(Format('SET NAMES %s', [Charset]));
    _Database.Params.Append(Format('lc_ctype=%s', [Charset]));
  end;
  if Login.Parameters.TryGetValue('DIALECT', Dialect) then
  begin
    _Database.Params.Append(Format('sql_dialect=%s', [Dialect]));
    _Database.SQLDialect := StrToInt(Dialect);
  end;
  if Login.Parameters.TryGetValue('DB_PATH', DBPath) then
  begin
    _Database.DatabaseName := DBPath;
  end;
  _Database.Connected := True;
  Result := _Database.Connected;
end;

function TFirebirdEngine.IsConnected: Boolean;
begin
  Result := _Database.Connected;
end;

function TFirebirdEngine.Disconnect: Boolean;
begin
  _Database.Connected := False;
  Result := not _Database.Connected;
end;

function TFirebirdEngine.OpenDataset(const Statement: WideString): IExecutionResult;
var
  Dataset: TUIBDataSet;
  Transaction: TUIBTransaction;
begin
  Dataset := TUIBDataSet.Create(_Database);
  Transaction := TUIBTransaction.Create(Dataset);
  Transaction.Database := _Database;
  Transaction.Options := [tpRead, tpNowait, tpReadCommitted, tpRecVersion];
  Dataset.Database := Transaction.Database;
  Dataset.Transaction := Transaction;
  Dataset.SQL.Text := Statement;
  try
    Dataset.Open;
    Result := TDatasetExecution.New(Statement, Dataset);
  except
    on E: Exception do
    begin
      Dataset.Free;
      Result := TFailedExecution.New(Statement, 0, E.Message);
    end;
  end;
end;

function TFirebirdEngine.ExecuteWithTransaction(const Statement: WideString;
  const Transaction: TUIBTransaction): IExecutionResult;
var
  ScriptExecute: TUIBScript;
begin
  ScriptExecute := TUIBScript.Create(_Database);
  try
    ScriptExecute.Database := _Database;
    ScriptExecute.Transaction := Transaction;
    ScriptExecute.Script.Text := Statement;
    if RightStr(Trim(ScriptExecute.Script.Text), 1) <> ';' then
      ScriptExecute.Script.Text := ScriptExecute.Script.Text + ';';
    try
      if not Transaction.InTransaction then
        Transaction.StartTransaction;
      ScriptExecute.ExecuteScript;
      Result := TSuccededExecution.New(Statement, 0);
    except
      on E: Exception do
      begin
        Transaction.RollBack;
        Result := TFailedExecution.New(Statement, 0, E.Message);
      end;
    end;
  finally
    ScriptExecute.Free;
  end;
end;

function TFirebirdEngine.Execute(const Statement: WideString; const UseGlobalTransaction: Boolean): IExecutionResult;
var
  Transaction: TUIBTransaction;
begin
  if UseGlobalTransaction then
    Result := ExecuteWithTransaction(Statement, _AlterTransaction)
  else
  begin
    Transaction := TUIBTransaction.Create(_Database);
    try
      Transaction.Database := _Database;
      Transaction.Options := _AlterTransaction.Options;
      Transaction.StartTransaction;
      Result := ExecuteWithTransaction(Statement, Transaction);
      Transaction.Commit;
    finally
      Transaction.Free;
    end;
  end;
end;

function TFirebirdEngine.ExecuteReturning(const Statement: WideString; const UseGlobalTransaction: Boolean)
  : IExecutionResult;
var
  Dataset: TUIBDataSet;
  Transaction: TUIBTransaction;
begin
  if UseGlobalTransaction then
    Transaction := _AlterTransaction
  else
  begin
    Transaction := TUIBTransaction.Create(_Database);
    Transaction.Database := _Database;
    Transaction.Options := [tpConcurrency, tpWait, tpWrite];
  end;
  Dataset := TUIBDataSet.Create(_Database);
  try
    Dataset.Database := _Database;
    Dataset.Transaction := Transaction;
    Dataset.SQL.Text := Statement;
    Transaction.StartTransaction;
    Dataset.Open;
    Transaction.Commit;
    Dataset.First;
    Result := TDatasetExecution.New(Statement, Dataset);
  except
    on E: Exception do
    begin
      Transaction.RollBack;
      Dataset.Free;
      Result := TFailedExecution.New(Statement, 0, E.Message);
    end;
  end;
end;

constructor TFirebirdEngine.Create;
begin
  _Database := TUIBDatabase.Create(nil);
  _AlterTransaction := TUIBTransaction.Create(_Database);
  _AlterTransaction.Database := _Database;
  _AlterTransaction.Options := [tpConcurrency, tpWait, tpWrite];
end;

destructor TFirebirdEngine.Destroy;
begin
  if InTransaction then
    RollbackTransaction;
  Disconnect;
  _AlterTransaction.Free;
  _Database.Free;
  inherited;
end;

class function TFirebirdEngine.New: IDatabaseEngine;
begin
  Result := TFirebirdEngine.Create;
end;

end.
